"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AwsCliCompatible = void 0;
const credential_providers_1 = require("@aws-sdk/credential-providers");
const ec2_metadata_service_1 = require("@aws-sdk/ec2-metadata-service");
const shared_ini_file_loader_1 = require("@smithy/shared-ini-file-loader");
const promptly = require("promptly");
const proxy_agent_1 = require("proxy-agent");
const util_1 = require("./util");
const logging_1 = require("../../logging");
const DEFAULT_CONNECTION_TIMEOUT = 10000;
const DEFAULT_TIMEOUT = 300000;
/**
 * Behaviors to match AWS CLI
 *
 * See these links:
 *
 * https://docs.aws.amazon.com/cli/latest/topic/config-vars.html
 * https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html
 */
class AwsCliCompatible {
    /**
     * Build an AWS CLI-compatible credential chain provider
     */
    static async credentialChainBuilder(options = {}) {
        /**
         * The previous implementation matched AWS CLI behavior:
         *
         * If a profile is explicitly set using `--profile`,
         * we use that to the exclusion of everything else.
         *
         * Note: this does not apply to AWS_PROFILE,
         * environment credentials still take precedence over AWS_PROFILE
         */
        if (options.profile) {
            return (0, credential_providers_1.fromIni)({
                profile: options.profile,
                ignoreCache: true,
                mfaCodeProvider: tokenCodeFn,
                clientConfig: {
                    requestHandler: AwsCliCompatible.requestHandlerBuilder(options.httpOptions),
                    customUserAgent: 'aws-cdk',
                    logger: options.logger,
                },
                logger: options.logger,
            });
        }
        const profile = options.profile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE;
        /**
         * Env AWS - EnvironmentCredentials with string AWS
         * Env Amazon - EnvironmentCredentials with string AMAZON
         * Profile Credentials - PatchedSharedIniFileCredentials with implicit profile, credentials file, http options, and token fn
         *    SSO with implicit profile only
         *    SharedIniFileCredentials with implicit profile and preferStaticCredentials true (profile with source_profile)
         *    Shared Credential file that points to Environment Credentials with AWS prefix
         *    Shared Credential file that points to EC2 Metadata
         *    Shared Credential file that points to ECS Credentials
         * SSO Credentials - SsoCredentials with implicit profile and http options
         * ProcessCredentials with implicit profile
         * ECS Credentials - ECSCredentials with no input OR Web Identity - TokenFileWebIdentityCredentials with no input OR EC2 Metadata - EC2MetadataCredentials with no input
         *
         * These translate to:
         * fromEnv()
         * fromSSO()/fromIni()
         * fromProcess()
         * fromContainerMetadata()
         * fromTokenFile()
         * fromInstanceMetadata()
         */
        const nodeProviderChain = (0, credential_providers_1.fromNodeProviderChain)({
            profile: profile,
            clientConfig: {
                requestHandler: AwsCliCompatible.requestHandlerBuilder(options.httpOptions),
                customUserAgent: 'aws-cdk',
                logger: options.logger,
            },
            logger: options.logger,
            ignoreCache: true,
        });
        return shouldPrioritizeEnv()
            ? (0, credential_providers_1.createCredentialChain)((0, credential_providers_1.fromEnv)(), nodeProviderChain).expireAfter(60 * 60000)
            : nodeProviderChain;
    }
    static requestHandlerBuilder(options = {}) {
        // Force it to use the proxy provided through the command line.
        // Otherwise, let the ProxyAgent auto-detect the proxy using environment variables.
        const getProxyForUrl = options.proxyAddress != null
            ? () => Promise.resolve(options.proxyAddress)
            : undefined;
        const agent = new proxy_agent_1.ProxyAgent({
            ca: tryGetCACert(options.caBundlePath),
            getProxyForUrl: getProxyForUrl,
        });
        return {
            connectionTimeout: DEFAULT_CONNECTION_TIMEOUT,
            requestTimeout: DEFAULT_TIMEOUT,
            httpsAgent: agent,
            httpAgent: agent,
        };
    }
    /**
     * Attempts to get the region from a number of sources and falls back to us-east-1 if no region can be found,
     * as is done in the AWS CLI.
     *
     * The order of priority is the following:
     *
     * 1. Environment variables specifying region, with both an AWS prefix and AMAZON prefix
     *    to maintain backwards compatibility, and without `DEFAULT` in the name because
     *    Lambda and CodeBuild set the $AWS_REGION variable.
     * 2. Regions listed in the Shared Ini Files - First checking for the profile provided
     *    and then checking for the default profile.
     * 3. IMDS instance identity region from the Metadata Service.
     * 4. us-east-1
     */
    static async region(maybeProfile) {
        const defaultRegion = 'us-east-1';
        const profile = maybeProfile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
        const region = process.env.AWS_REGION ||
            process.env.AMAZON_REGION ||
            process.env.AWS_DEFAULT_REGION ||
            process.env.AMAZON_DEFAULT_REGION ||
            (await getRegionFromIni(profile)) ||
            (await regionFromMetadataService());
        if (!region) {
            const usedProfile = !profile ? '' : ` (profile: "${profile}")`;
            (0, logging_1.debug)(`Unable to determine AWS region from environment or AWS configuration${usedProfile}, defaulting to '${defaultRegion}'`);
            return defaultRegion;
        }
        return region;
    }
}
exports.AwsCliCompatible = AwsCliCompatible;
/**
 * Looks up the region of the provided profile. If no region is present,
 * it will attempt to lookup the default region.
 * @param profile The profile to use to lookup the region
 * @returns The region for the profile or default profile, if present. Otherwise returns undefined.
 */
async function getRegionFromIni(profile) {
    const sharedFiles = await (0, shared_ini_file_loader_1.loadSharedConfigFiles)({ ignoreCache: true });
    // Priority:
    //
    // credentials come before config because aws-cli v1 behaves like that.
    //
    // 1. profile-region-in-credentials
    // 2. profile-region-in-config
    // 3. default-region-in-credentials
    // 4. default-region-in-config
    return getRegionFromIniFile(profile, sharedFiles.credentialsFile)
        ?? getRegionFromIniFile(profile, sharedFiles.configFile)
        ?? getRegionFromIniFile('default', sharedFiles.credentialsFile)
        ?? getRegionFromIniFile('default', sharedFiles.configFile);
}
function getRegionFromIniFile(profile, data) {
    return data?.[profile]?.region;
}
function tryGetCACert(bundlePath) {
    const path = bundlePath || caBundlePathFromEnvironment();
    if (path) {
        (0, logging_1.debug)('Using CA bundle path: %s', path);
        return (0, util_1.readIfPossible)(path);
    }
    return undefined;
}
/**
 * Find and return a CA certificate bundle path to be passed into the SDK.
 */
function caBundlePathFromEnvironment() {
    if (process.env.aws_ca_bundle) {
        return process.env.aws_ca_bundle;
    }
    if (process.env.AWS_CA_BUNDLE) {
        return process.env.AWS_CA_BUNDLE;
    }
    return undefined;
}
/**
 * We used to support both AWS and AMAZON prefixes for these environment variables.
 *
 * Adding this for backward compatibility.
 */
function shouldPrioritizeEnv() {
    const id = process.env.AWS_ACCESS_KEY_ID || process.env.AMAZON_ACCESS_KEY_ID;
    const key = process.env.AWS_SECRET_ACCESS_KEY || process.env.AMAZON_SECRET_ACCESS_KEY;
    if (!!id && !!key) {
        process.env.AWS_ACCESS_KEY_ID = id;
        process.env.AWS_SECRET_ACCESS_KEY = key;
        const sessionToken = process.env.AWS_SESSION_TOKEN ?? process.env.AMAZON_SESSION_TOKEN;
        if (sessionToken) {
            process.env.AWS_SESSION_TOKEN = sessionToken;
        }
        return true;
    }
    return false;
}
/**
 * The MetadataService class will attempt to fetch the instance identity document from
 * IMDSv2 first, and then will attempt v1 as a fallback.
 *
 * If this fails, we will use us-east-1 as the region so no error should be thrown.
 * @returns The region for the instance identity
 */
async function regionFromMetadataService() {
    (0, logging_1.debug)('Looking up AWS region in the EC2 Instance Metadata Service (IMDS).');
    try {
        const metadataService = new ec2_metadata_service_1.MetadataService({
            httpOptions: {
                timeout: 1000,
            },
        });
        await metadataService.fetchMetadataToken();
        const document = await metadataService.request('/latest/dynamic/instance-identity/document', {});
        return JSON.parse(document).region;
    }
    catch (e) {
        (0, logging_1.debug)(`Unable to retrieve AWS region from IMDS: ${e}`);
    }
}
/**
 * Ask user for MFA token for given serial
 *
 * Result is send to callback function for SDK to authorize the request
 */
async function tokenCodeFn(serialArn) {
    (0, logging_1.debug)('Require MFA token for serial ARN', serialArn);
    try {
        const token = await promptly.prompt(`MFA token for ${serialArn}: `, {
            trim: true,
            default: '',
        });
        (0, logging_1.debug)('Successfully got MFA token from user');
        return token;
    }
    catch (err) {
        (0, logging_1.debug)('Failed to get MFA token', err);
        const e = new Error(`Error fetching MFA token: ${err.message ?? err}`);
        e.name = 'SharedIniFileCredentialsProviderFailure';
        throw e;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXdzY2xpLWNvbXBhdGlibGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJhd3NjbGktY29tcGF0aWJsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSx3RUFBK0c7QUFDL0csd0VBQWdFO0FBRWhFLDJFQUF1RTtBQUV2RSxxQ0FBcUM7QUFDckMsNkNBQXlDO0FBRXpDLGlDQUF3QztBQUN4QywyQ0FBc0M7QUFFdEMsTUFBTSwwQkFBMEIsR0FBRyxLQUFLLENBQUM7QUFDekMsTUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDO0FBRS9COzs7Ozs7O0dBT0c7QUFDSCxNQUFhLGdCQUFnQjtJQUMzQjs7T0FFRztJQUNJLE1BQU0sQ0FBQyxLQUFLLENBQUMsc0JBQXNCLENBQ3hDLFVBQWtDLEVBQUU7UUFFcEM7Ozs7Ozs7O1dBUUc7UUFDSCxJQUFJLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNwQixPQUFPLElBQUEsOEJBQU8sRUFBQztnQkFDYixPQUFPLEVBQUUsT0FBTyxDQUFDLE9BQU87Z0JBQ3hCLFdBQVcsRUFBRSxJQUFJO2dCQUNqQixlQUFlLEVBQUUsV0FBVztnQkFDNUIsWUFBWSxFQUFFO29CQUNaLGNBQWMsRUFBRSxnQkFBZ0IsQ0FBQyxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDO29CQUMzRSxlQUFlLEVBQUUsU0FBUztvQkFDMUIsTUFBTSxFQUFFLE9BQU8sQ0FBQyxNQUFNO2lCQUN2QjtnQkFDRCxNQUFNLEVBQUUsT0FBTyxDQUFDLE1BQU07YUFDdkIsQ0FBQyxDQUFDO1FBQ0wsQ0FBQztRQUVELE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQztRQUU5Rjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7V0FvQkc7UUFDSCxNQUFNLGlCQUFpQixHQUFHLElBQUEsNENBQXFCLEVBQUM7WUFDOUMsT0FB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LElBQUEsZUFBSyxFQUFDLGtDQUFrQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ3JELElBQUksQ0FBQztRQUNILE1BQU0sS0FBSyxHQUFXLE1BQU0sUUFBUSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsU0FBUyxJQUFJLEVBQUU7WUFDMUUsSUFBSSxFQUFFLElBQUk7WUFDVixPQUFPLEVBQUUsRUFBRTtTQUNaLENBQUMsQ0FBQztRQUNILElBQUEsZUFBSyxFQUFDLHNDQUFzQyxDQUFDLENBQUM7UUFDOUMsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBQUMsT0FBTyxHQUFRLEVBQUUsQ0FBQztRQUNsQixJQUFBLGVBQUssRUFBQyx5QkFBeUIsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUN0QyxNQUFNLENBQUMsR0FBRyxJQUFJLEtBQUssQ0FBQyw2QkFBNkIsR0FBRyxDQUFDLE9BQU8sSUFBSSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZFLENBQUMsQ0FBQyxJQUFJLEdBQUcseUNBQXlDLENBQUM7UUFDbkQsTUFBTSxDQUFDLENBQUM7SUFDVixDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNyZWRlbnRpYWxDaGFpbiwgZnJvbUVudiwgZnJvbUluaSwgZnJvbU5vZGVQcm92aWRlckNoYWluIH0gZnJvbSAnQGF3cy1zZGsvY3JlZGVudGlhbC1wcm92aWRlcnMnO1xuaW1wb3J0IHsgTWV0YWRhdGFTZXJ2aWNlIH0gZnJvbSAnQGF3cy1zZGsvZWMyLW1ldGFkYXRhLXNlcnZpY2UnO1xuaW1wb3J0IHR5cGUgeyBOb2RlSHR0cEhhbmRsZXJPcHRpb25zIH0gZnJvbSAnQHNtaXRoeS9ub2RlLWh0dHAtaGFuZGxlcic7XG5pbXBvcnQgeyBsb2FkU2hhcmVkQ29uZmlnRmlsZXMgfSBmcm9tICdAc21pdGh5L3NoYXJlZC1pbmktZmlsZS1sb2FkZXInO1xuaW1wb3J0IHsgQXdzQ3JlZGVudGlhbElkZW50aXR5UHJvdmlkZXIsIExvZ2dlciB9IGZyb20gJ0BzbWl0aHkvdHlwZXMnO1xuaW1wb3J0ICogYXMgcHJvbXB0bHkgZnJvbSAncHJvbXB0bHknO1xuaW1wb3J0IHsgUHJveHlBZ2VudCB9IGZyb20gJ3Byb3h5LWFnZW50JztcbmltcG9ydCB0eXBlIHsgU2RrSHR0cE9wdGlvbnMgfSBmcm9tICcuL3Nkay1wcm92aWRlcic7XG5pbXBvcnQgeyByZWFkSWZQb3NzaWJsZSB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuXG5jb25zdCBERUZBVUxUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDEwMDAwO1xuY29uc3QgREVGQVVMVF9USU1FT1VUID0gMzAwMDAwO1xuXG4vKipcbiAqIEJlaGF2aW9ycyB0byBtYXRjaCBBV1MgQ0xJXG4gKlxuICogU2VlIHRoZXNlIGxpbmtzOlxuICpcbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9jbGkvbGF0ZXN0L3RvcGljL2NvbmZpZy12YXJzLmh0bWxcbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9jbGkvbGF0ZXN0L3VzZXJndWlkZS9jbGktY29uZmlndXJlLWVudnZhcnMuaHRtbFxuICovXG5leHBvcnQgY2xhc3MgQXdzQ2xpQ29tcGF0aWJsZSB7XG4gIC8qKlxuICAgKiBCdWlsZCBhbiBBV1MgQ0xJLWNvbXBhdGlibGUgY3JlZGVudGlhbCBjaGFpbiBwcm92aWRlclxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyBjcmVkZW50aWFsQ2hhaW5CdWlsZGVyKFxuICAgIG9wdGlvbnM6IENyZWRlbnRpYWxDaGFpbk9wdGlvbnMgPSB7fSxcbiAgKTogUHJvbWlzZTxBd3NDcmVkZW50aWFsSWRlbnRpdHlQcm92aWRlcj4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyBpbXBsZW1lbnRhdGlvbiBtYXRjaGVkIEFXUyBDTEkgYmVoYXZpb3I6XG4gICAgICpcbiAgICAgKiBJZiBhIHByb2ZpbGUgaXMgZXhwbGljaXRseSBzZXQgdXNpbmcgYC0tcHJvZmlsZWAsXG4gICAgICogd2UgdXNlIHRoYXQgdG8gdGhlIGV4Y2x1c2lvbiBvZiBldmVyeXRoaW5nIGVsc2UuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIGRvZXMgbm90IGFwcGx5IHRvIEFXU19QUk9GSUxFLFxuICAgICAqIGVudmlyb25tZW50IGNyZWRlbnRpYWxzIHN0aWxsIHRha2UgcHJlY2VkZW5jZSBvdmVyIEFXU19QUk9GSUxFXG4gICAgICovXG4gICAgaWYgKG9wdGlvbnMucHJvZmlsZSkge1xuICAgICAgcmV0dXJuIGZyb21Jbmkoe1xuICAgICAgICBwcm9maWxlOiBvcHRpb25zLnByb2ZpbGUsXG4gICAgICAgIGlnbm9yZUNhY2hlOiB0cnVlLFxuICAgICAgICBtZmFDb2RlUHJvdmlkZXI6IHRva2VuQ29kZUZuLFxuICAgICAgICBjbGllbnRDb25maWc6IHtcbiAgICAgICAgICByZXF1ZXN0SGFuZGxlcjogQXdzQ2xpQ29tcGF0aWJsZS5yZXF1ZXN0SGFuZGxlckJ1aWxkZXIob3B0aW9ucy5odHRwT3B0aW9ucyksXG4gICAgICAgICAgY3VzdG9tVXNlckFnZW50OiAnYXdzLWNkaycsXG4gICAgICAgICAgbG9nZ2VyOiBvcHRpb25zLmxvZ2dlcixcbiAgICAgICAgfSxcbiAgICAgICAgbG9nZ2VyOiBvcHRpb25zLmxvZ2dlcixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHByb2ZpbGUgPSBvcHRpb25zLnByb2ZpbGUgfHwgcHJvY2Vzcy5lbnYuQVdTX1BST0ZJTEUgfHwgcHJvY2Vzcy5lbnYuQVdTX0RFRkFVTFRfUFJPRklMRTtcblxuICAgIC8qKlxuICAgICAqIEVudiBBV1MgLSBFbnZpcm9ubWVudENyZWRlbnRpYWxzIHdpdGggc3RyaW5nIEFXU1xuICAgICAqIEVudiBBbWF6b24gLSBFbnZpcm9ubWVudENyZWRlbnRpYWxzIHdpdGggc3RyaW5nIEFNQVpPTlxuICAgICAqIFByb2ZpbGUgQ3JlZGVudGlhbHMgLSBQYXRjaGVkU2hhcmVkSW5pRmlsZUNyZWRlbnRpYWxzIHdpdGggaW1wbGljaXQgcHJvZmlsZSwgY3JlZGVudGlhbHMgZmlsZSwgaHR0cCBvcHRpb25zLCBhbmQgdG9rZW4gZm5cbiAgICAgKiAgICBTU08gd2l0aCBpbXBsaWNpdCBwcm9maWxlIG9ubHlcbiAgICAgKiAgICBTaGFyZWRJbmlGaWxlQ3JlZGVudGlhbHMgd2l0aCBpbXBsaWNpdCBwcm9maWxlIGFuZCBwcmVmZXJTdGF0aWNDcmVkZW50aWFscyB0cnVlIChwcm9maWxlIHdpdGggc291cmNlX3Byb2ZpbGUpXG4gICAgICogICAgU2hhcmVkIENyZWRlbnRpYWwgZmlsZSB0aGF0IHBvaW50cyB0byBFbnZpcm9ubWVudCBDcmVkZW50aWFscyB3aXRoIEFXUyBwcmVmaXhcbiAgICAgKiAgICBTaGFyZWQgQ3JlZGVudGlhbCBmaWxlIHRoYXQgcG9pbnRzIHRvIEVDMiBNZXRhZGF0YVxuICAgICAqICAgIFNoYXJlZCBDcmVkZW50aWFsIGZpbGUgdGhhdCBwb2ludHMgdG8gRUNTIENyZWRlbnRpYWxzXG4gICAgICogU1NPIENyZWRlbnRpYWxzIC0gU3NvQ3JlZGVudGlhbHMgd2l0aCBpbXBsaWNpdCBwcm9maWxlIGFuZCBodHRwIG9wdGlvbnNcbiAgICAgKiBQcm9jZXNzQ3JlZGVudGlhbHMgd2l0aCBpbXBsaWNpdCBwcm9maWxlXG4gICAgICogRUNTIENyZWRlbnRpYWxzIC0gRUNTQ3JlZGVudGlhbHMgd2l0aCBubyBpbnB1dCBPUiBXZWIgSWRlbnRpdHkgLSBUb2tlbkZpbGVXZWJJZGVudGl0eUNyZWRlbnRpYWxzIHdpdGggbm8gaW5wdXQgT1IgRUMyIE1ldGFkYXRhIC0gRUMyTWV0YWRhdGFDcmVkZW50aWFscyB3aXRoIG5vIGlucHV0XG4gICAgICpcbiAgICAgKiBUaGVzZSB0cmFuc2xhdGUgdG86XG4gICAgICogZnJvbUVudigpXG4gICAgICogZnJvbVNTTygpL2Zyb21JbmkoKVxuICAgICAqIGZyb21Qcm9jZXNzKClcbiAgICAgKiBmcm9tQ29udGFpbmVyTWV0YWRhdGEoKVxuICAgICAqIGZyb21Ub2tlbkZpbGUoKVxuICAgICAqIGZyb21JbnN0YW5jZU1ldGFkYXRhKClcbiAgICAgKi9cbiAgICBjb25zdCBub2RlUHJvdmlkZXJDaGFpbiA9IGZyb21Ob2RlUHJvdmlkZXJDaGFpbih7XG4gICAgICBwcm9maWxlOiBwcm9maWxlLFxuICAgICAgY2xpZW50Q29uZmlnOiB7XG4gICAgICAgIHJlcXVlc3RIYW5kbGVyOiBBd3NDbGlDb21wYXRpYmxlLnJlcXVlc3RIYW5kbGVyQnVpbGRlcihvcHRpb25zLmh0dHBPcHRpb25zKSxcbiAgICAgICAgY3VzdG9tVXNlckFnZW50OiAnYXdzLWNkaycsXG4gICAgICAgIGxvZ2dlcjogb3B0aW9ucy5sb2dnZXIsXG4gICAgICB9LFxuICAgICAgbG9nZ2VyOiBvcHRpb25zLmxvZ2dlcixcbiAgICAgIGlnbm9yZUNhY2hlOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNob3VsZFByaW9yaXRpemVFbnYoKVxuICAgICAgPyBjcmVhdGVDcmVkZW50aWFsQ2hhaW4oZnJvbUVudigpLCBub2RlUHJvdmlkZXJDaGFpbikuZXhwaXJlQWZ0ZXIoNjAgKiA2MF8wMDApXG4gICAgICA6IG5vZGVQcm92aWRlckNoYWluO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyByZXF1ZXN0SGFuZGxlckJ1aWxkZXIob3B0aW9uczogU2RrSHR0cE9wdGlvbnMgPSB7fSk6IE5vZGVIdHRwSGFuZGxlck9wdGlvbnMge1xuICAgIC8vIEZvcmNlIGl0IHRvIHVzZSB0aGUgcHJveHkgcHJvdmlkZWQgdGhyb3VnaCB0aGUgY29tbWFuZCBsaW5lLlxuICAgIC8vIE90aGVyd2lzZSwgbGV0IHRoZSBQcm94eUFnZW50IGF1dG8tZGV0ZWN0IHRoZSBwcm94eSB1c2luZyBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gICAgY29uc3QgZ2V0UHJveHlGb3JVcmwgPSBvcHRpb25zLnByb3h5QWRkcmVzcyAhPSBudWxsXG4gICAgICA/ICgpID0+IFByb21pc2UucmVzb2x2ZShvcHRpb25zLnByb3h5QWRkcmVzcyEpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IGFnZW50ID0gbmV3IFByb3h5QWdlbnQoe1xuICAgICAgY2E6IHRyeUdldENBQ2VydChvcHRpb25zLmNhQnVuZGxlUGF0aCksXG4gICAgICBnZXRQcm94eUZvclVybDogZ2V0UHJveHlGb3JVcmwsXG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29ubmVjdGlvblRpbWVvdXQ6IERFRkFVTFRfQ09OTkVDVElPTl9USU1FT1VULFxuICAgICAgcmVxdWVzdFRpbWVvdXQ6IERFRkFVTFRfVElNRU9VVCxcbiAgICAgIGh0dHBzQWdlbnQ6IGFnZW50LFxuICAgICAgaHR0cEFnZW50OiBhZ2VudCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGdldCB0aGUgcmVnaW9uIGZyb20gYSBudW1iZXIgb2Ygc291cmNlcyBhbmQgZmFsbHMgYmFjayB0byB1cy1lYXN0LTEgaWYgbm8gcmVnaW9uIGNhbiBiZSBmb3VuZCxcbiAgICogYXMgaXMgZG9uZSBpbiB0aGUgQVdTIENMSS5cbiAgICpcbiAgICogVGhlIG9yZGVyIG9mIHByaW9yaXR5IGlzIHRoZSBmb2xsb3dpbmc6XG4gICAqXG4gICAqIDEuIEVudmlyb25tZW50IHZhcmlhYmxlcyBzcGVjaWZ5aW5nIHJlZ2lvbiwgd2l0aCBib3RoIGFuIEFXUyBwcmVmaXggYW5kIEFNQVpPTiBwcmVmaXhcbiAgICogICAgdG8gbWFpbnRhaW4gYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGFuZCB3aXRob3V0IGBERUZBVUxUYCBpbiB0aGUgbmFtZSBiZWNhdXNlXG4gICAqICAgIExhbWJkYSBhbmQgQ29kZUJ1aWxkIHNldCB0aGUgJEFXU19SRUdJT04gdmFyaWFibGUuXG4gICAqIDIuIFJlZ2lvbnMgbGlzdGVkIGluIHRoZSBTaGFyZWQgSW5pIEZpbGVzIC0gRmlyc3QgY2hlY2tpbmcgZm9yIHRoZSBwcm9maWxlIHByb3ZpZGVkXG4gICAqICAgIGFuZCB0aGVuIGNoZWNraW5nIGZvciB0aGUgZGVmYXVsdCBwcm9maWxlLlxuICAgKiAzLiBJTURTIGluc3RhbmNlIGlkZW50aXR5IHJlZ2lvbiBmcm9tIHRoZSBNZXRhZGF0YSBTZXJ2aWNlLlxuICAgKiA0LiB1cy1lYXN0LTFcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgcmVnaW9uKG1heWJlUHJvZmlsZT86IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgZGVmYXVsdFJlZ2lvbiA9ICd1cy1lYXN0LTEnO1xuICAgIGNvbnN0IHByb2ZpbGUgPSBtYXliZVByb2ZpbGUgfHwgcHJvY2Vzcy5lbnYuQVdTX1BST0ZJTEUgfHwgcHJvY2Vzcy5lbnYuQVdTX0RFRkFVTFRfUFJPRklMRSB8fCAnZGVmYXVsdCc7XG5cbiAgICBjb25zdCByZWdpb24gPVxuICAgICAgcHJvY2Vzcy5lbnYuQVdTX1JFR0lPTiB8fFxuICAgICAgcHJvY2Vzcy5lbnYuQU1BWk9OX1JFR0lPTiB8fFxuICAgICAgcHJvY2Vzcy5lbnYuQVdTX0RFRkFVTFRfUkVHSU9OIHx8XG4gICAgICBwcm9jZXNzLmVudi5BTUFaT05fREVGQVVMVF9SRUdJT04gfHxcbiAgICAgIChhd2FpdCBnZXRSZWdpb25Gcm9tSW5pKHByb2ZpbGUpKSB8fFxuICAgICAgKGF3YWl0IHJlZ2lvbkZyb21NZXRhZGF0YVNlcnZpY2UoKSk7XG5cbiAgICBpZiAoIXJlZ2lvbikge1xuICAgICAgY29uc3QgdXNlZFByb2ZpbGUgPSAhcHJvZmlsZSA/ICcnIDogYCAocHJvZmlsZTogXCIke3Byb2ZpbGV9XCIpYDtcbiAgICAgIGRlYnVnKFxuICAgICAgICBgVW5hYmxlIHRvIGRldGVybWluZSBBV1MgcmVnaW9uIGZyb20gZW52aXJvbm1lbnQgb3IgQVdTIGNvbmZpZ3VyYXRpb24ke3VzZWRQcm9maWxlfSwgZGVmYXVsdGluZyB0byAnJHtkZWZhdWx0UmVnaW9ufSdgLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkZWZhdWx0UmVnaW9uO1xuICAgIH1cblxuICAgIHJldHVybiByZWdpb247XG4gIH1cbn1cblxuLyoqXG4gKiBMb29rcyB1cCB0aGUgcmVnaW9uIG9mIHRoZSBwcm92aWRlZCBwcm9maWxlLiBJZiBubyByZWdpb24gaXMgcHJlc2VudCxcbiAqIGl0IHdpbGwgYXR0ZW1wdCB0byBsb29rdXAgdGhlIGRlZmF1bHQgcmVnaW9uLlxuICogQHBhcmFtIHByb2ZpbGUgVGhlIHByb2ZpbGUgdG8gdXNlIHRvIGxvb2t1cCB0aGUgcmVnaW9uXG4gKiBAcmV0dXJucyBUaGUgcmVnaW9uIGZvciB0aGUgcHJvZmlsZSBvciBkZWZhdWx0IHByb2ZpbGUsIGlmIHByZXNlbnQuIE90aGVyd2lzZSByZXR1cm5zIHVuZGVmaW5lZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UmVnaW9uRnJvbUluaShwcm9maWxlOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICBjb25zdCBzaGFyZWRGaWxlcyA9IGF3YWl0IGxvYWRTaGFyZWRDb25maWdGaWxlcyh7IGlnbm9yZUNhY2hlOiB0cnVlIH0pO1xuXG4gIC8vIFByaW9yaXR5OlxuICAvL1xuICAvLyBjcmVkZW50aWFscyBjb21lIGJlZm9yZSBjb25maWcgYmVjYXVzZSBhd3MtY2xpIHYxIGJlaGF2ZXMgbGlrZSB0aGF0LlxuICAvL1xuICAvLyAxLiBwcm9maWxlLXJlZ2lvbi1pbi1jcmVkZW50aWFsc1xuICAvLyAyLiBwcm9maWxlLXJlZ2lvbi1pbi1jb25maWdcbiAgLy8gMy4gZGVmYXVsdC1yZWdpb24taW4tY3JlZGVudGlhbHNcbiAgLy8gNC4gZGVmYXVsdC1yZWdpb24taW4tY29uZmlnXG5cbiAgcmV0dXJuIGdldFJlZ2lvbkZyb21JbmlGaWxlKHByb2ZpbGUsIHNoYXJlZEZpbGVzLmNyZWRlbnRpYWxzRmlsZSlcbiAgICA/PyBnZXRSZWdpb25Gcm9tSW5pRmlsZShwcm9maWxlLCBzaGFyZWRGaWxlcy5jb25maWdGaWxlKVxuICAgID8/IGdldFJlZ2lvbkZyb21JbmlGaWxlKCdkZWZhdWx0Jywgc2hhcmVkRmlsZXMuY3JlZGVudGlhbHNGaWxlKVxuICAgID8/IGdldFJlZ2lvbkZyb21JbmlGaWxlKCdkZWZhdWx0Jywgc2hhcmVkRmlsZXMuY29uZmlnRmlsZSk7XG5cbn1cblxuZnVuY3Rpb24gZ2V0UmVnaW9uRnJvbUluaUZpbGUocHJvZmlsZTogc3RyaW5nLCBkYXRhPzogYW55KSB7XG4gIHJldHVybiBkYXRhPy5bcHJvZmlsZV0/LnJlZ2lvbjtcbn1cblxuZnVuY3Rpb24gdHJ5R2V0Q0FDZXJ0KGJ1bmRsZVBhdGg/OiBzdHJpbmcpIHtcbiAgY29uc3QgcGF0aCA9IGJ1bmRsZVBhdGggfHwgY2FCdW5kbGVQYXRoRnJvbUVudmlyb25tZW50KCk7XG4gIGlmIChwYXRoKSB7XG4gICAgZGVidWcoJ1VzaW5nIENBIGJ1bmRsZSBwYXRoOiAlcycsIHBhdGgpO1xuICAgIHJldHVybiByZWFkSWZQb3NzaWJsZShwYXRoKTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEZpbmQgYW5kIHJldHVybiBhIENBIGNlcnRpZmljYXRlIGJ1bmRsZSBwYXRoIHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBTREsuXG4gKi9cbmZ1bmN0aW9uIGNhQnVuZGxlUGF0aEZyb21FbnZpcm9ubWVudCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAocHJvY2Vzcy5lbnYuYXdzX2NhX2J1bmRsZSkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5hd3NfY2FfYnVuZGxlO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5BV1NfQ0FfQlVORExFKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LkFXU19DQV9CVU5ETEU7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBXZSB1c2VkIHRvIHN1cHBvcnQgYm90aCBBV1MgYW5kIEFNQVpPTiBwcmVmaXhlcyBmb3IgdGhlc2UgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICpcbiAqIEFkZGluZyB0aGlzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICovXG5mdW5jdGlvbiBzaG91bGRQcmlvcml0aXplRW52KCkge1xuICBjb25zdCBpZCA9IHByb2Nlc3MuZW52LkFXU19BQ0NFU1NfS0VZX0lEIHx8IHByb2Nlc3MuZW52LkFNQVpPTl9BQ0NFU1NfS0VZX0lEO1xuICBjb25zdCBrZXkgPSBwcm9jZXNzLmVudi5BV1NfU0VDUkVUX0FDQ0VTU19LRVkgfHwgcHJvY2Vzcy5lbnYuQU1BWk9OX1NFQ1JFVF9BQ0NFU1NfS0VZO1xuXG4gIGlmICghIWlkICYmICEha2V5KSB7XG4gICAgcHJvY2Vzcy5lbnYuQVdTX0FDQ0VTU19LRVlfSUQgPSBpZDtcbiAgICBwcm9jZXNzLmVudi5BV1NfU0VDUkVUX0FDQ0VTU19LRVkgPSBrZXk7XG5cbiAgICBjb25zdCBzZXNzaW9uVG9rZW4gPSBwcm9jZXNzLmVudi5BV1NfU0VTU0lPTl9UT0tFTiA/PyBwcm9jZXNzLmVudi5BTUFaT05fU0VTU0lPTl9UT0tFTjtcbiAgICBpZiAoc2Vzc2lvblRva2VuKSB7XG4gICAgICBwcm9jZXNzLmVudi5BV1NfU0VTU0lPTl9UT0tFTiA9IHNlc3Npb25Ub2tlbjtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBUaGUgTWV0YWRhdGFTZXJ2aWNlIGNsYXNzIHdpbGwgYXR0ZW1wdCB0byBmZXRjaCB0aGUgaW5zdGFuY2UgaWRlbnRpdHkgZG9jdW1lbnQgZnJvbVxuICogSU1EU3YyIGZpcnN0LCBhbmQgdGhlbiB3aWxsIGF0dGVtcHQgdjEgYXMgYSBmYWxsYmFjay5cbiAqXG4gKiBJZiB0aGlzIGZhaWxzLCB3ZSB3aWxsIHVzZSB1cy1lYXN0LTEgYXMgdGhlIHJlZ2lvbiBzbyBubyBlcnJvciBzaG91bGQgYmUgdGhyb3duLlxuICogQHJldHVybnMgVGhlIHJlZ2lvbiBmb3IgdGhlIGluc3RhbmNlIGlkZW50aXR5XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlZ2lvbkZyb21NZXRhZGF0YVNlcnZpY2UoKSB7XG4gIGRlYnVnKCdMb29raW5nIHVwIEFXUyByZWdpb24gaW4gdGhlIEVDMiBJbnN0YW5jZSBNZXRhZGF0YSBTZXJ2aWNlIChJTURTKS4nKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBtZXRhZGF0YVNlcnZpY2UgPSBuZXcgTWV0YWRhdGFTZXJ2aWNlKHtcbiAgICAgIGh0dHBPcHRpb25zOiB7XG4gICAgICAgIHRpbWVvdXQ6IDEwMDAsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgYXdhaXQgbWV0YWRhdGFTZXJ2aWNlLmZldGNoTWV0YWRhdGFUb2tlbigpO1xuICAgIGNvbnN0IGRvY3VtZW50ID0gYXdhaXQgbWV0YWRhdGFTZXJ2aWNlLnJlcXVlc3QoJy9sYXRlc3QvZHluYW1pYy9pbnN0YW5jZS1pZGVudGl0eS9kb2N1bWVudCcsIHt9KTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShkb2N1bWVudCkucmVnaW9uO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoYFVuYWJsZSB0byByZXRyaWV2ZSBBV1MgcmVnaW9uIGZyb20gSU1EUzogJHtlfWApO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlZGVudGlhbENoYWluT3B0aW9ucyB7XG4gIHJlYWRvbmx5IHByb2ZpbGU/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IGh0dHBPcHRpb25zPzogU2RrSHR0cE9wdGlvbnM7XG4gIHJlYWRvbmx5IGxvZ2dlcj86IExvZ2dlcjtcbn1cblxuLyoqXG4gKiBBc2sgdXNlciBmb3IgTUZBIHRva2VuIGZvciBnaXZlbiBzZXJpYWxcbiAqXG4gKiBSZXN1bHQgaXMgc2VuZCB0byBjYWxsYmFjayBmdW5jdGlvbiBmb3IgU0RLIHRvIGF1dGhvcml6ZSB0aGUgcmVxdWVzdFxuICovXG5hc3luYyBmdW5jdGlvbiB0b2tlbkNvZGVGbihzZXJpYWxBcm46IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGRlYnVnKCdSZXF1aXJlIE1GQSB0b2tlbiBmb3Igc2VyaWFsIEFSTicsIHNlcmlhbEFybik7XG4gIHRyeSB7XG4gICAgY29uc3QgdG9rZW46IHN0cmluZyA9IGF3YWl0IHByb21wdGx5LnByb21wdChgTUZBIHRva2VuIGZvciAke3NlcmlhbEFybn06IGAsIHtcbiAgICAgIHRyaW06IHRydWUsXG4gICAgICBkZWZhdWx0OiAnJyxcbiAgICB9KTtcbiAgICBkZWJ1ZygnU3VjY2Vzc2Z1bGx5IGdvdCBNRkEgdG9rZW4gZnJvbSB1c2VyJyk7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgIGRlYnVnKCdGYWlsZWQgdG8gZ2V0IE1GQSB0b2tlbicsIGVycik7XG4gICAgY29uc3QgZSA9IG5ldyBFcnJvcihgRXJyb3IgZmV0Y2hpbmcgTUZBIHRva2VuOiAke2Vyci5tZXNzYWdlID8/IGVycn1gKTtcbiAgICBlLm5hbWUgPSAnU2hhcmVkSW5pRmlsZUNyZWRlbnRpYWxzUHJvdmlkZXJGYWlsdXJlJztcbiAgICB0aHJvdyBlO1xuICB9XG59XG4iXX0=