"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceImporter = void 0;
exports.removeNonImportResources = removeNonImportResources;
const cfnDiff = require("@aws-cdk/cloudformation-diff");
const chalk = require("chalk");
const fs = require("fs-extra");
const promptly = require("promptly");
const deploy_stack_1 = require("./api/deploy-stack");
const logging_1 = require("./logging");
/**
 * Resource importing utility class
 *
 * - Determines the resources added to a template (compared to the deployed version)
 * - Look up the identification information
 *   - Load them from a file, or
 *   - Ask the user, based on information supplied to us by CloudFormation's GetTemplateSummary
 * - Translate the input to a structure expected by CloudFormation, update the template to add the
 *   importable resources, then run an IMPORT changeset.
 */
class ResourceImporter {
    constructor(stack, cfn) {
        this.stack = stack;
        this.cfn = cfn;
    }
    /**
     * Ask the user for resources to import
     */
    async askForResourceIdentifiers(available) {
        const ret = { importResources: [], resourceMap: {} };
        const resourceIdentifiers = await this.resourceIdentifiers();
        for (const resource of available) {
            const identifier = await this.askForResourceIdentifier(resourceIdentifiers, resource);
            if (!identifier) {
                continue;
            }
            ret.importResources.push(resource);
            ret.resourceMap[resource.logicalId] = identifier;
        }
        return ret;
    }
    /**
     * Load the resources to import from a file
     */
    async loadResourceIdentifiers(available, filename) {
        const contents = await fs.readJson(filename);
        const ret = { importResources: [], resourceMap: {} };
        for (const resource of available) {
            const descr = this.describeResource(resource.logicalId);
            const idProps = contents[resource.logicalId];
            if (idProps) {
                (0, logging_1.print)('%s: importing using %s', chalk.blue(descr), chalk.blue(fmtdict(idProps)));
                ret.importResources.push(resource);
                ret.resourceMap[resource.logicalId] = idProps;
                delete contents[resource.logicalId];
            }
            else {
                (0, logging_1.print)('%s: skipping', chalk.blue(descr));
            }
        }
        const unknown = Object.keys(contents);
        if (unknown.length > 0) {
            (0, logging_1.warning)(`Unrecognized resource identifiers in mapping file: ${unknown.join(', ')}`);
        }
        return ret;
    }
    /**
     * Based on the provided resource mapping, prepare CFN structures for import (template,
     * ResourcesToImport structure) and perform the import operation (CloudFormation deployment)
     *
     * @param importMap Mapping from CDK construct tree path to physical resource import identifiers
     * @param options Options to pass to CloudFormation deploy operation
     */
    async importResourcesFromMap(importMap, options) {
        const resourcesToImport = await this.makeResourcesToImport(importMap);
        const updatedTemplate = await this.currentTemplateWithAdditions(importMap.importResources);
        await this.importResources(updatedTemplate, resourcesToImport, options);
    }
    /**
     * Based on the app and resources file generated by cdk migrate. Removes all items from the template that
     * cannot be included in an import change-set for new stacks and performs the import operation,
     * creating the new stack.
     *
     * @param resourcesToImport The mapping created by cdk migrate
     * @param options Options to pass to CloudFormation deploy operation
     */
    async importResourcesFromMigrate(resourcesToImport, options) {
        const updatedTemplate = this.removeNonImportResources();
        await this.importResources(updatedTemplate, resourcesToImport, options);
    }
    async importResources(overrideTemplate, resourcesToImport, options) {
        try {
            const result = await this.cfn.deployStack({
                stack: this.stack,
                deployName: this.stack.stackName,
                ...options,
                overrideTemplate,
                resourcesToImport,
            });
            (0, deploy_stack_1.assertIsSuccessfulDeployStackResult)(result);
            const message = result.noOp
                ? ' ✅  %s (no changes)'
                : ' ✅  %s';
            (0, logging_1.success)('\n' + message, this.stack.displayName);
        }
        catch (e) {
            (0, logging_1.error)('\n ❌  %s failed: %s', chalk.bold(this.stack.displayName), e);
            throw e;
        }
    }
    /**
     * Perform a diff between the currently running and the new template, ensure that it is valid
     * for importing and return a list of resources that are being added in the new version
     *
     * @return mapping logicalResourceId -> resourceDifference
     */
    async discoverImportableResources(allowNonAdditions = false) {
        const currentTemplate = await this.currentTemplate();
        const diff = cfnDiff.fullDiff(currentTemplate, this.stack.template);
        // Ignore changes to CDKMetadata
        const resourceChanges = Object.entries(diff.resources.changes)
            .filter(([logicalId, _]) => logicalId !== 'CDKMetadata');
        // Split the changes into additions and non-additions. Imports only make sense
        // for newly-added resources.
        const nonAdditions = resourceChanges.filter(([_, dif]) => !dif.isAddition);
        const additions = resourceChanges.filter(([_, dif]) => dif.isAddition);
        if (nonAdditions.length) {
            const offendingResources = nonAdditions.map(([logId, _]) => this.describeResource(logId));
            if (allowNonAdditions) {
                (0, logging_1.warning)(`Ignoring updated/deleted resources (--force): ${offendingResources.join(', ')}`);
            }
            else {
                throw new Error('No resource updates or deletes are allowed on import operation. Make sure to resolve pending changes ' +
                    `to existing resources, before attempting an import. Updated/deleted resources: ${offendingResources.join(', ')} (--force to override)`);
            }
        }
        // Resources in the new template, that are not present in the current template, are a potential import candidates
        return {
            additions: additions.map(([logicalId, resourceDiff]) => ({
                logicalId,
                resourceDiff,
                resourceDefinition: addDefaultDeletionPolicy(this.stack.template?.Resources?.[logicalId] ?? {}),
            })),
            hasNonAdditions: nonAdditions.length > 0,
        };
    }
    /**
     * Resolves the environment of a stack.
     */
    async resolveEnvironment() {
        return this.cfn.resolveEnvironment(this.stack);
    }
    /**
     * Get currently deployed template of the given stack (SINGLETON)
     *
     * @returns Currently deployed CloudFormation template
     */
    async currentTemplate() {
        if (!this._currentTemplate) {
            this._currentTemplate = await this.cfn.readCurrentTemplate(this.stack);
        }
        return this._currentTemplate;
    }
    /**
     * Return the current template, with the given resources added to it
     */
    async currentTemplateWithAdditions(additions) {
        const template = await this.currentTemplate();
        if (!template.Resources) {
            template.Resources = {};
        }
        for (const add of additions) {
            template.Resources[add.logicalId] = add.resourceDefinition;
        }
        return template;
    }
    /**
     * Get a list of import identifiers for all resource types used in the given
     * template that do support the import operation (SINGLETON)
     *
     * @returns a mapping from a resource type to a list of property names that together identify the resource for import
     */
    async resourceIdentifiers() {
        const ret = {};
        const resourceIdentifierSummaries = await this.cfn.resourceIdentifierSummaries(this.stack);
        for (const summary of resourceIdentifierSummaries) {
            if ('ResourceType' in summary && summary.ResourceType && 'ResourceIdentifiers' in summary && summary.ResourceIdentifiers) {
                ret[summary.ResourceType] = (summary.ResourceIdentifiers ?? [])?.map(x => x.split(','));
            }
        }
        return ret;
    }
    /**
     * Ask for the importable identifier for the given resource
     *
     * There may be more than one identifier under which a resource can be imported. The `import`
     * operation needs exactly one of them.
     *
     * - If we can get one from the template, we will use one.
     * - Otherwise, we will ask the user for one of them.
     */
    async askForResourceIdentifier(resourceIdentifiers, chg) {
        const resourceName = this.describeResource(chg.logicalId);
        // Skip resources that do not support importing
        const resourceType = chg.resourceDiff.newResourceType;
        if (resourceType === undefined || !(resourceType in resourceIdentifiers)) {
            (0, logging_1.warning)(`${resourceName}: unsupported resource type ${resourceType}, skipping import.`);
            return undefined;
        }
        const idPropSets = resourceIdentifiers[resourceType];
        // Retain only literal strings: strip potential CFN intrinsics
        const resourceProps = Object.fromEntries(Object.entries(chg.resourceDefinition.Properties ?? {})
            .filter(([_, v]) => typeof v === 'string'));
        // Find property sets that are fully satisfied in the template, ask the user to confirm them
        const satisfiedPropSets = idPropSets.filter(ps => ps.every(p => resourceProps[p]));
        for (const satisfiedPropSet of satisfiedPropSets) {
            const candidateProps = Object.fromEntries(satisfiedPropSet.map(p => [p, resourceProps[p]]));
            const displayCandidateProps = fmtdict(candidateProps);
            if (await promptly.confirm(`${chalk.blue(resourceName)} (${resourceType}): import with ${chalk.yellow(displayCandidateProps)} (yes/no) [default: yes]? `, { default: 'yes' })) {
                return candidateProps;
            }
        }
        // If we got here and the user rejected any available identifiers, then apparently they don't want the resource at all
        if (satisfiedPropSets.length > 0) {
            (0, logging_1.print)(chalk.grey(`Skipping import of ${resourceName}`));
            return undefined;
        }
        // We cannot auto-import this, ask the user for one of the props
        // The only difference between these cases is what we print: for multiple properties, we print a preamble
        const prefix = `${chalk.blue(resourceName)} (${resourceType})`;
        let preamble;
        let promptPattern;
        if (idPropSets.length > 1) {
            preamble = `${prefix}: enter one of ${idPropSets.map(x => chalk.blue(x.join('+'))).join(', ')} to import (all empty to skip)`;
            promptPattern = `${prefix}: enter %`;
        }
        else {
            promptPattern = `${prefix}: enter %`;
        }
        // Do the input loop here
        if (preamble) {
            (0, logging_1.print)(preamble);
        }
        for (const idProps of idPropSets) {
            const input = {};
            for (const idProp of idProps) {
                // If we have a value from the template, use it as default. This will only be a partial
                // identifier if present, otherwise we would have done the import already above.
                const defaultValue = resourceProps[idProp] ?? '';
                const prompt = [
                    promptPattern.replace(/%/g, chalk.blue(idProp)),
                    defaultValue
                        ? `[${defaultValue}]`
                        : '(empty to skip)',
                ].join(' ') + ':';
                const response = await promptly.prompt(prompt, { default: defaultValue, trim: true });
                if (!response) {
                    break;
                }
                input[idProp] = response;
                // Also stick this property into 'resourceProps', so that it may be reused by a subsequent question
                // (for a different compound identifier that involves the same property). Just a small UX enhancement.
                resourceProps[idProp] = response;
            }
            // If the user gave inputs for all values, we are complete
            if (Object.keys(input).length === idProps.length) {
                return input;
            }
        }
        (0, logging_1.print)(chalk.grey(`Skipping import of ${resourceName}`));
        return undefined;
    }
    /**
     * Convert the internal "resource mapping" structure to CloudFormation accepted "ResourcesToImport" structure
     */
    async makeResourcesToImport(resourceMap) {
        return resourceMap.importResources.map(res => ({
            LogicalResourceId: res.logicalId,
            ResourceType: res.resourceDiff.newResourceType,
            ResourceIdentifier: resourceMap.resourceMap[res.logicalId],
        }));
    }
    /**
     * Convert CloudFormation logical resource ID to CDK construct tree path
     *
     * @param logicalId CloudFormation logical ID of the resource (the key in the template's Resources section)
     * @returns Forward-slash separated path of the resource in CDK construct tree, e.g. MyStack/MyBucket/Resource
     */
    describeResource(logicalId) {
        return this.stack.template?.Resources?.[logicalId]?.Metadata?.['aws:cdk:path'] ?? logicalId;
    }
    /**
     * Removes CDKMetadata and Outputs in the template so that only resources for importing are left.
     * @returns template with import resources only
     */
    removeNonImportResources() {
        return removeNonImportResources(this.stack);
    }
}
exports.ResourceImporter = ResourceImporter;
/**
 * Removes CDKMetadata and Outputs in the template so that only resources for importing are left.
 * @returns template with import resources only
 */
function removeNonImportResources(stack) {
    const template = stack.template;
    delete template.Resources.CDKMetadata;
    delete template.Outputs;
    return template;
}
function fmtdict(xs) {
    return Object.entries(xs).map(([k, v]) => `${k}=${v}`).join(', ');
}
/**
 * Add a default `DeletionPolicy` policy.
 * The default value is set to 'Retain', to lower risk of unintentionally
 * deleting stateful resources in the process of importing to CDK.
 */
function addDefaultDeletionPolicy(resource) {
    if (resource.DeletionPolicy) {
        return resource;
    }
    return {
        ...resource,
        DeletionPolicy: 'Retain',
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW1wb3J0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiaW1wb3J0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQThZQSw0REFLQztBQWxaRCx3REFBd0Q7QUFHeEQsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFFckMscURBQXlFO0FBS3pFLHVDQUEyRDtBQXVDM0Q7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBYSxnQkFBZ0I7SUFHM0IsWUFDbUIsS0FBd0MsRUFDeEMsR0FBZ0I7UUFEaEIsVUFBSyxHQUFMLEtBQUssQ0FBbUM7UUFDeEMsUUFBRyxHQUFILEdBQUcsQ0FBYTtJQUFJLENBQUM7SUFFeEM7O09BRUc7SUFDSSxLQUFLLENBQUMseUJBQXlCLENBQUMsU0FBK0I7UUFDcEUsTUFBTSxHQUFHLEdBQWMsRUFBRSxlQUFlLEVBQUUsRUFBRSxFQUFFLFdBQVcsRUFBRSxFQUFFLEVBQUUsQ0FBQztRQUNoRSxNQUFNLG1CQUFtQixHQUFHLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7UUFFN0QsS0FBSyxNQUFNLFFBQVEsSUFBSSxTQUFTLEVBQUUsQ0FBQztZQUNqQyxNQUFNLFVBQVUsR0FBRyxNQUFNLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxtQkFBbUIsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUN0RixJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7Z0JBQ2hCLFNBQVM7WUFDWCxDQUFDO1lBRUQsR0FBRyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDbkMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEdBQUcsVUFBVSxDQUFDO1FBQ25ELENBQUM7UUFFRCxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFRDs7T0FFRztJQUNJLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxTQUErQixFQUFFLFFBQWdCO1FBQ3BGLE1BQU0sUUFBUSxHQUFHLE1BQU0sRUFBRSxDQUFD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Q0QsU0FBUyxPQUFPLENBQUksRUFBcUI7SUFDdkMsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNwRSxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQVMsd0JBQXdCLENBQUMsUUFBYTtJQUM3QyxJQUFJLFFBQVEsQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUFDLE9BQU8sUUFBUSxDQUFDO0lBQUMsQ0FBQztJQUVqRCxPQUFPO1FBQ0wsR0FBRyxRQUFRO1FBQ1gsY0FBYyxFQUFFLFFBQVE7S0FDekIsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZXBsb3lPcHRpb25zIH0gZnJvbSAnQGF3cy1jZGsvY2xvdWQtYXNzZW1ibHktc2NoZW1hJztcbmltcG9ydCAqIGFzIGNmbkRpZmYgZnJvbSAnQGF3cy1jZGsvY2xvdWRmb3JtYXRpb24tZGlmZic7XG5pbXBvcnQgeyBSZXNvdXJjZURpZmZlcmVuY2UgfSBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyBwcm9tcHRseSBmcm9tICdwcm9tcHRseSc7XG5pbXBvcnQgeyBEZXBsb3ltZW50TWV0aG9kIH0gZnJvbSAnLi9hcGknO1xuaW1wb3J0IHsgYXNzZXJ0SXNTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQgfSBmcm9tICcuL2FwaS9kZXBsb3ktc3RhY2snO1xuaW1wb3J0IHsgRGVwbG95bWVudHMgfSBmcm9tICcuL2FwaS9kZXBsb3ltZW50cyc7XG5pbXBvcnQgeyBSZXNvdXJjZUlkZW50aWZpZXJQcm9wZXJ0aWVzLCBSZXNvdXJjZXNUb0ltcG9ydCB9IGZyb20gJy4vYXBpL3V0aWwvY2xvdWRmb3JtYXRpb24nO1xuaW1wb3J0IHsgU3RhY2tBY3Rpdml0eVByb2dyZXNzIH0gZnJvbSAnLi9hcGkvdXRpbC9jbG91ZGZvcm1hdGlvbi9zdGFjay1hY3Rpdml0eS1tb25pdG9yJztcbmltcG9ydCB7IFRhZyB9IGZyb20gJy4vY2RrLXRvb2xraXQnO1xuaW1wb3J0IHsgZXJyb3IsIHByaW50LCBzdWNjZXNzLCB3YXJuaW5nIH0gZnJvbSAnLi9sb2dnaW5nJztcblxuZXhwb3J0IGludGVyZmFjZSBJbXBvcnREZXBsb3ltZW50T3B0aW9ucyBleHRlbmRzIERlcGxveU9wdGlvbnMge1xuICBkZXBsb3ltZW50TWV0aG9kPzogRGVwbG95bWVudE1ldGhvZDtcbiAgcHJvZ3Jlc3M/OiBTdGFja0FjdGl2aXR5UHJvZ3Jlc3M7XG4gIHRhZ3M/OiBUYWdbXTtcbn1cblxuLyoqXG4gKiBTZXQgb2YgcGFyYW1ldGVycyB0aGF0IHVuaXF1ZWx5IGlkZW50aWZ5IGEgcGh5c2ljYWwgcmVzb3VyY2Ugb2YgYSBnaXZlbiB0eXBlXG4gKiBmb3IgdGhlIGltcG9ydCBvcGVyYXRpb24sIGV4YW1wbGU6XG4gKlxuICogYGBgXG4gKiB7XG4gKiAgIFwiQVdTOjpTMzo6QnVja2V0XCI6IFtbXCJCdWNrZXROYW1lXCJdXSxcbiAqICAgXCJBV1M6OkR5bmFtb0RCOjpHbG9iYWxUYWJsZVwiOiBbW1wiVGFibGVOYW1lXCJdLCBbXCJUYWJsZUFyblwiXSwgW1wiVGFibGVTdHJlYW1Bcm5cIl1dLFxuICogICBcIkFXUzo6Um91dGU1Mzo6S2V5U2lnbmluZ0tleVwiOiBbW1wiSG9zdGVkWm9uZUlkXCIsIFwiTmFtZVwiXV0sXG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IHR5cGUgUmVzb3VyY2VJZGVudGlmaWVycyA9IHsgW3Jlc291cmNlVHlwZTogc3RyaW5nXTogc3RyaW5nW11bXSB9O1xuXG4vKipcbiAqIE1hcHBpbmcgb2YgQ0RLIHJlc291cmNlcyAoTDEgY29uc3RydWN0cykgdG8gcGh5c2ljYWwgcmVzb3VyY2VzIHRvIGJlIGltcG9ydGVkXG4gKiBpbiB0aGVpciBwbGFjZSwgZXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqIHtcbiAqICAgXCJNeVN0YWNrL015UzNCdWNrZXQvUmVzb3VyY2VcIjoge1xuICogICAgIFwiQnVja2V0TmFtZVwiOiBcIm15LW1hbnVhbGx5LWNyZWF0ZWQtczMtYnVja2V0XCJcbiAqICAgfSxcbiAqICAgXCJNeVN0YWNrL015VnBjL1Jlc291cmNlXCI6IHtcbiAqICAgICBcIlZwY0lkXCI6IFwidnBjLTEyMzQ1Njc4OVwiXG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgdHlwZSBSZXNvdXJjZU1hcCA9IHsgW2xvZ2ljYWxSZXNvdXJjZTogc3RyaW5nXTogUmVzb3VyY2VJZGVudGlmaWVyUHJvcGVydGllcyB9O1xuXG4vKipcbiAqIFJlc291cmNlIGltcG9ydGluZyB1dGlsaXR5IGNsYXNzXG4gKlxuICogLSBEZXRlcm1pbmVzIHRoZSByZXNvdXJjZXMgYWRkZWQgdG8gYSB0ZW1wbGF0ZSAoY29tcGFyZWQgdG8gdGhlIGRlcGxveWVkIHZlcnNpb24pXG4gKiAtIExvb2sgdXAgdGhlIGlkZW50aWZpY2F0aW9uIGluZm9ybWF0aW9uXG4gKiAgIC0gTG9hZCB0aGVtIGZyb20gYSBmaWxlLCBvclxuICogICAtIEFzayB0aGUgdXNlciwgYmFzZWQgb24gaW5mb3JtYXRpb24gc3VwcGxpZWQgdG8gdXMgYnkgQ2xvdWRGb3JtYXRpb24ncyBHZXRUZW1wbGF0ZVN1bW1hcnlcbiAqIC0gVHJhbnNsYXRlIHRoZSBpbnB1dCB0byBhIHN0cnVjdHVyZSBleHBlY3RlZCBieSBDbG91ZEZvcm1hdGlvbiwgdXBkYXRlIHRoZSB0ZW1wbGF0ZSB0byBhZGQgdGhlXG4gKiAgIGltcG9ydGFibGUgcmVzb3VyY2VzLCB0aGVuIHJ1biBhbiBJTVBPUlQgY2hhbmdlc2V0LlxuICovXG5leHBvcnQgY2xhc3MgUmVzb3VyY2VJbXBvcnRlciB7XG4gIHByaXZhdGUgX2N1cnJlbnRUZW1wbGF0ZTogYW55O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNmbjogRGVwbG95bWVudHMpIHsgfVxuXG4gIC8qKlxuICAgKiBBc2sgdGhlIHVzZXIgZm9yIHJlc291cmNlcyB0byBpbXBvcnRcbiAgICovXG4gIHB1YmxpYyBhc3luYyBhc2tGb3JSZXNvdXJjZUlkZW50aWZpZXJzKGF2YWlsYWJsZTogSW1wb3J0YWJsZVJlc291cmNlW10pOiBQcm9taXNlPEltcG9ydE1hcD4ge1xuICAgIGNvbnN0IHJldDogSW1wb3J0TWFwID0geyBpbXBvcnRSZXNvdXJjZXM6IFtdLCByZXNvdXJjZU1hcDoge30gfTtcbiAgICBjb25zdCByZXNvdXJjZUlkZW50aWZpZXJzID0gYXdhaXQgdGhpcy5yZXNvdXJjZUlkZW50aWZpZXJzKCk7XG5cbiAgICBmb3IgKGNvbnN0IHJlc291cmNlIG9mIGF2YWlsYWJsZSkge1xuICAgICAgY29uc3QgaWRlbnRpZmllciA9IGF3YWl0IHRoaXMuYXNrRm9yUmVzb3VyY2VJZGVudGlmaWVyKHJlc291cmNlSWRlbnRpZmllcnMsIHJlc291cmNlKTtcbiAgICAgIGlmICghaWRlbnRpZmllcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcmV0LmltcG9ydFJlc291cmNlcy5wdXNoKHJlc291cmNlKTtcbiAgICAgIHJldC5yZXNvdXJjZU1hcFtyZXNvdXJjZS5sb2dpY2FsSWRdID0gaWRlbnRpZmllcjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgdGhlIHJlc291cmNlcyB0byBpbXBvcnQgZnJvbSBhIGZpbGVcbiAgICovXG4gIHB1YmxpYyBhc3luYyBsb2FkUmVzb3VyY2VJZGVudGlmaWVycyhhdmFpbGFibGU6IEltcG9ydGFibGVSZXNvdXJjZVtdLCBmaWxlbmFtZTogc3RyaW5nKTogUHJvbWlzZTxJbXBvcnRNYXA+IHtcbiAgICBjb25zdCBjb250ZW50cyA9IGF3YWl0IGZzLnJlYWRKc29uKGZpbGVuYW1lKTtcblxuICAgIGNvbnN0IHJldDogSW1wb3J0TWFwID0geyBpbXBvcnRSZXNvdXJjZXM6IFtdLCByZXNvdXJjZU1hcDoge30gfTtcbiAgICBmb3IgKGNvbnN0IHJlc291cmNlIG9mIGF2YWlsYWJsZSkge1xuICAgICAgY29uc3QgZGVzY3IgPSB0aGlzLmRlc2NyaWJlUmVzb3VyY2UocmVzb3VyY2UubG9naWNhbElkKTtcbiAgICAgIGNvbnN0IGlkUHJvcHMgPSBjb250ZW50c1tyZXNvdXJjZS5sb2dpY2FsSWRdO1xuICAgICAgaWYgKGlkUHJvcHMpIHtcbiAgICAgICAgcHJpbnQoJyVzOiBpbXBvcnRpbmcgdXNpbmcgJXMnLCBjaGFsay5ibHVlKGRlc2NyKSwgY2hhbGsuYmx1ZShmbXRkaWN0KGlkUHJvcHMpKSk7XG5cbiAgICAgICAgcmV0LmltcG9ydFJlc291cmNlcy5wdXNoKHJlc291cmNlKTtcbiAgICAgICAgcmV0LnJlc291cmNlTWFwW3Jlc291cmNlLmxvZ2ljYWxJZF0gPSBpZFByb3BzO1xuICAgICAgICBkZWxldGUgY29udGVudHNbcmVzb3VyY2UubG9naWNhbElkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByaW50KCclczogc2tpcHBpbmcnLCBjaGFsay5ibHVlKGRlc2NyKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdW5rbm93biA9IE9iamVjdC5rZXlzKGNvbnRlbnRzKTtcbiAgICBpZiAodW5rbm93bi5sZW5ndGggPiAwKSB7XG4gICAgICB3YXJuaW5nKGBVbnJlY29nbml6ZWQgcmVzb3VyY2UgaWRlbnRpZmllcnMgaW4gbWFwcGluZyBmaWxlOiAke3Vua25vd24uam9pbignLCAnKX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIEJhc2VkIG9uIHRoZSBwcm92aWRlZCByZXNvdXJjZSBtYXBwaW5nLCBwcmVwYXJlIENGTiBzdHJ1Y3R1cmVzIGZvciBpbXBvcnQgKHRlbXBsYXRlLFxuICAgKiBSZXNvdXJjZXNUb0ltcG9ydCBzdHJ1Y3R1cmUpIGFuZCBwZXJmb3JtIHRoZSBpbXBvcnQgb3BlcmF0aW9uIChDbG91ZEZvcm1hdGlvbiBkZXBsb3ltZW50KVxuICAgKlxuICAgKiBAcGFyYW0gaW1wb3J0TWFwIE1hcHBpbmcgZnJvbSBDREsgY29uc3RydWN0IHRyZWUgcGF0aCB0byBwaHlzaWNhbCByZXNvdXJjZSBpbXBvcnQgaWRlbnRpZmllcnNcbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIHRvIENsb3VkRm9ybWF0aW9uIGRlcGxveSBvcGVyYXRpb25cbiAgICovXG4gIHB1YmxpYyBhc3luYyBpbXBvcnRSZXNvdXJjZXNGcm9tTWFwKGltcG9ydE1hcDogSW1wb3J0TWFwLCBvcHRpb25zOiBJbXBvcnREZXBsb3ltZW50T3B0aW9ucykge1xuICAgIGNvbnN0IHJlc291cmNlc1RvSW1wb3J0OiBSZXNvdXJjZXNUb0ltcG9ydCA9IGF3YWl0IHRoaXMubWFrZVJlc291cmNlc1RvSW1wb3J0KGltcG9ydE1hcCk7XG4gICAgY29uc3QgdXBkYXRlZFRlbXBsYXRlID0gYXdhaXQgdGhpcy5jdXJyZW50VGVtcGxhdGVXaXRoQWRkaXRpb25zKGltcG9ydE1hcC5pbXBvcnRSZXNvdXJjZXMpO1xuXG4gICAgYXdhaXQgdGhpcy5pbXBvcnRSZXNvdXJjZXModXBkYXRlZFRlbXBsYXRlLCByZXNvdXJjZXNUb0ltcG9ydCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQmFzZWQgb24gdGhlIGFwcCBhbmQgcmVzb3VyY2VzIGZpbGUgZ2VuZXJhdGVkIGJ5IGNkayBtaWdyYXRlLiBSZW1vdmVzIGFsbCBpdGVtcyBmcm9tIHRoZSB0ZW1wbGF0ZSB0aGF0XG4gICAqIGNhbm5vdCBiZSBpbmNsdWRlZCBpbiBhbiBpbXBvcnQgY2hhbmdlLXNldCBmb3IgbmV3IHN0YWNrcyBhbmQgcGVyZm9ybXMgdGhlIGltcG9ydCBvcGVyYXRpb24sXG4gICAqIGNyZWF0aW5nIHRoZSBuZXcgc3RhY2suXG4gICAqXG4gICAqIEBwYXJhbSByZXNvdXJjZXNUb0ltcG9ydCBUaGUgbWFwcGluZyBjcmVhdGVkIGJ5IGNkayBtaWdyYXRlXG4gICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gcGFzcyB0byBDbG91ZEZvcm1hdGlvbiBkZXBsb3kgb3BlcmF0aW9uXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaW1wb3J0UmVzb3VyY2VzRnJvbU1pZ3JhdGUocmVzb3VyY2VzVG9JbXBvcnQ6IFJlc291cmNlc1RvSW1wb3J0LCBvcHRpb25zOiBJbXBvcnREZXBsb3ltZW50T3B0aW9ucykge1xuICAgIGNvbnN0IHVwZGF0ZWRUZW1wbGF0ZSA9IHRoaXMucmVtb3ZlTm9uSW1wb3J0UmVzb3VyY2VzKCk7XG5cbiAgICBhd2FpdCB0aGlzLmltcG9ydFJlc291cmNlcyh1cGRhdGVkVGVtcGxhdGUsIHJlc291cmNlc1RvSW1wb3J0LCBvcHRpb25zKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW1wb3J0UmVzb3VyY2VzKG92ZXJyaWRlVGVtcGxhdGU6IGFueSwgcmVzb3VyY2VzVG9JbXBvcnQ6IFJlc291cmNlc1RvSW1wb3J0LCBvcHRpb25zOiBJbXBvcnREZXBsb3ltZW50T3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNmbi5kZXBsb3lTdGFjayh7XG4gICAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgICBkZXBsb3lOYW1lOiB0aGlzLnN0YWNrLnN0YWNrTmFtZSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgb3ZlcnJpZGVUZW1wbGF0ZSxcbiAgICAgICAgcmVzb3VyY2VzVG9JbXBvcnQsXG4gICAgICB9KTtcblxuICAgICAgYXNzZXJ0SXNTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQocmVzdWx0KTtcblxuICAgICAgY29uc3QgbWVzc2FnZSA9IHJlc3VsdC5ub09wXG4gICAgICAgID8gJyDinIUgICVzIChubyBjaGFuZ2VzKSdcbiAgICAgICAgOiAnIOKchSAgJXMnO1xuXG4gICAgICBzdWNjZXNzKCdcXG4nICsgbWVzc2FnZSwgdGhpcy5zdGFjay5kaXNwbGF5TmFtZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IoJ1xcbiDinYwgICVzIGZhaWxlZDogJXMnLCBjaGFsay5ib2xkKHRoaXMuc3RhY2suZGlzcGxheU5hbWUpLCBlKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBkaWZmIGJldHdlZW4gdGhlIGN1cnJlbnRseSBydW5uaW5nIGFuZCB0aGUgbmV3IHRlbXBsYXRlLCBlbnN1cmUgdGhhdCBpdCBpcyB2YWxpZFxuICAgKiBmb3IgaW1wb3J0aW5nIGFuZCByZXR1cm4gYSBsaXN0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBiZWluZyBhZGRlZCBpbiB0aGUgbmV3IHZlcnNpb25cbiAgICpcbiAgICogQHJldHVybiBtYXBwaW5nIGxvZ2ljYWxSZXNvdXJjZUlkIC0+IHJlc291cmNlRGlmZmVyZW5jZVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpc2NvdmVySW1wb3J0YWJsZVJlc291cmNlcyhhbGxvd05vbkFkZGl0aW9ucyA9IGZhbHNlKTogUHJvbWlzZTxEaXNjb3ZlckltcG9ydGFibGVSZXNvdXJjZXNSZXN1bHQ+IHtcbiAgICBjb25zdCBjdXJyZW50VGVtcGxhdGUgPSBhd2FpdCB0aGlzLmN1cnJlbnRUZW1wbGF0ZSgpO1xuXG4gICAgY29uc3QgZGlmZiA9IGNmbkRpZmYuZnVsbERpZmYoY3VycmVudFRlbXBsYXRlLCB0aGlzLnN0YWNrLnRlbXBsYXRlKTtcblxuICAgIC8vIElnbm9yZSBjaGFuZ2VzIHRvIENES01ldGFkYXRhXG4gICAgY29uc3QgcmVzb3VyY2VDaGFuZ2VzID0gT2JqZWN0LmVudHJpZXMoZGlmZi5yZXNvdXJjZXMuY2hhbmdlcylcbiAgICAgIC5maWx0ZXIoKFtsb2dpY2FsSWQsIF9dKSA9PiBsb2dpY2FsSWQgIT09ICdDREtNZXRhZGF0YScpO1xuXG4gICAgLy8gU3BsaXQgdGhlIGNoYW5nZXMgaW50byBhZGRpdGlvbnMgYW5kIG5vbi1hZGRpdGlvbnMuIEltcG9ydHMgb25seSBtYWtlIHNlbnNlXG4gICAgLy8gZm9yIG5ld2x5LWFkZGVkIHJlc291cmNlcy5cbiAgICBjb25zdCBub25BZGRpdGlvbnMgPSByZXNvdXJjZUNoYW5nZXMuZmlsdGVyKChbXywgZGlmXSkgPT4gIWRpZi5pc0FkZGl0aW9uKTtcbiAgICBjb25zdCBhZGRpdGlvbnMgPSByZXNvdXJjZUNoYW5nZXMuZmlsdGVyKChbXywgZGlmXSkgPT4gZGlmLmlzQWRkaXRpb24pO1xuXG4gICAgaWYgKG5vbkFkZGl0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG9mZmVuZGluZ1Jlc291cmNlcyA9IG5vbkFkZGl0aW9ucy5tYXAoKFtsb2dJZCwgX10pID0+IHRoaXMuZGVzY3JpYmVSZXNvdXJjZShsb2dJZCkpO1xuXG4gICAgICBpZiAoYWxsb3dOb25BZGRpdGlvbnMpIHtcbiAgICAgICAgd2FybmluZyhgSWdub3JpbmcgdXBkYXRlZC9kZWxldGVkIHJlc291cmNlcyAoLS1mb3JjZSk6ICR7b2ZmZW5kaW5nUmVzb3VyY2VzLmpvaW4oJywgJyl9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlc291cmNlIHVwZGF0ZXMgb3IgZGVsZXRlcyBhcmUgYWxsb3dlZCBvbiBpbXBvcnQgb3BlcmF0aW9uLiBNYWtlIHN1cmUgdG8gcmVzb2x2ZSBwZW5kaW5nIGNoYW5nZXMgJyArXG4gICAgICAgICAgYHRvIGV4aXN0aW5nIHJlc291cmNlcywgYmVmb3JlIGF0dGVtcHRpbmcgYW4gaW1wb3J0LiBVcGRhdGVkL2RlbGV0ZWQgcmVzb3VyY2VzOiAke29mZmVuZGluZ1Jlc291cmNlcy5qb2luKCcsICcpfSAoLS1mb3JjZSB0byBvdmVycmlkZSlgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXNvdXJjZXMgaW4gdGhlIG5ldyB0ZW1wbGF0ZSwgdGhhdCBhcmUgbm90IHByZXNlbnQgaW4gdGhlIGN1cnJlbnQgdGVtcGxhdGUsIGFyZSBhIHBvdGVudGlhbCBpbXBvcnQgY2FuZGlkYXRlc1xuICAgIHJldHVybiB7XG4gICAgICBhZGRpdGlvbnM6IGFkZGl0aW9ucy5tYXAoKFtsb2dpY2FsSWQsIHJlc291cmNlRGlmZl0pID0+ICh7XG4gICAgICAgIGxvZ2ljYWxJZCxcbiAgICAgICAgcmVzb3VyY2VEaWZmLFxuICAgICAgICByZXNvdXJjZURlZmluaXRpb246IGFkZERlZmF1bHREZWxldGlvblBvbGljeSh0aGlzLnN0YWNrLnRlbXBsYXRlPy5SZXNvdXJjZXM/Lltsb2dpY2FsSWRdID8/IHt9KSxcbiAgICAgIH0pKSxcbiAgICAgIGhhc05vbkFkZGl0aW9uczogbm9uQWRkaXRpb25zLmxlbmd0aCA+IDAsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGUgZW52aXJvbm1lbnQgb2YgYSBzdGFjay5cbiAgICovXG4gIHB1YmxpYyBhc3luYyByZXNvbHZlRW52aXJvbm1lbnQoKTogUHJvbWlzZTxjeGFwaS5FbnZpcm9ubWVudD4ge1xuICAgIHJldHVybiB0aGlzLmNmbi5yZXNvbHZlRW52aXJvbm1lbnQodGhpcy5zdGFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnRseSBkZXBsb3llZCB0ZW1wbGF0ZSBvZiB0aGUgZ2l2ZW4gc3RhY2sgKFNJTkdMRVRPTilcbiAgICpcbiAgICogQHJldHVybnMgQ3VycmVudGx5IGRlcGxveWVkIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGN1cnJlbnRUZW1wbGF0ZSgpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghdGhpcy5fY3VycmVudFRlbXBsYXRlKSB7XG4gICAgICB0aGlzLl9jdXJyZW50VGVtcGxhdGUgPSBhd2FpdCB0aGlzLmNmbi5yZWFkQ3VycmVudFRlbXBsYXRlKHRoaXMuc3RhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFRlbXBsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY3VycmVudCB0ZW1wbGF0ZSwgd2l0aCB0aGUgZ2l2ZW4gcmVzb3VyY2VzIGFkZGVkIHRvIGl0XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGN1cnJlbnRUZW1wbGF0ZVdpdGhBZGRpdGlvbnMoYWRkaXRpb25zOiBJbXBvcnRhYmxlUmVzb3VyY2VbXSk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBhd2FpdCB0aGlzLmN1cnJlbnRUZW1wbGF0ZSgpO1xuICAgIGlmICghdGVtcGxhdGUuUmVzb3VyY2VzKSB7XG4gICAgICB0ZW1wbGF0ZS5SZXNvdXJjZXMgPSB7fTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGFkZCBvZiBhZGRpdGlvbnMpIHtcbiAgICAgIHRlbXBsYXRlLlJlc291cmNlc1thZGQubG9naWNhbElkXSA9IGFkZC5yZXNvdXJjZURlZmluaXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgaW1wb3J0IGlkZW50aWZpZXJzIGZvciBhbGwgcmVzb3VyY2UgdHlwZXMgdXNlZCBpbiB0aGUgZ2l2ZW5cbiAgICogdGVtcGxhdGUgdGhhdCBkbyBzdXBwb3J0IHRoZSBpbXBvcnQgb3BlcmF0aW9uIChTSU5HTEVUT04pXG4gICAqXG4gICAqIEByZXR1cm5zIGEgbWFwcGluZyBmcm9tIGEgcmVzb3VyY2UgdHlwZSB0byBhIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMgdGhhdCB0b2dldGhlciBpZGVudGlmeSB0aGUgcmVzb3VyY2UgZm9yIGltcG9ydFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyByZXNvdXJjZUlkZW50aWZpZXJzKCk6IFByb21pc2U8UmVzb3VyY2VJZGVudGlmaWVycz4ge1xuICAgIGNvbnN0IHJldDogUmVzb3VyY2VJZGVudGlmaWVycyA9IHt9O1xuICAgIGNvbnN0IHJlc291cmNlSWRlbnRpZmllclN1bW1hcmllcyA9IGF3YWl0IHRoaXMuY2ZuLnJlc291cmNlSWRlbnRpZmllclN1bW1hcmllcyh0aGlzLnN0YWNrKTtcbiAgICBmb3IgKGNvbnN0IHN1bW1hcnkgb2YgcmVzb3VyY2VJZGVudGlmaWVyU3VtbWFyaWVzKSB7XG4gICAgICBpZiAoJ1Jlc291cmNlVHlwZScgaW4gc3VtbWFyeSAmJiBzdW1tYXJ5LlJlc291cmNlVHlwZSAmJiAnUmVzb3VyY2VJZGVudGlmaWVycycgaW4gc3VtbWFyeSAmJiBzdW1tYXJ5LlJlc291cmNlSWRlbnRpZmllcnMpIHtcbiAgICAgICAgcmV0W3N1bW1hcnkuUmVzb3VyY2VUeXBlXSA9IChzdW1tYXJ5LlJlc291cmNlSWRlbnRpZmllcnMgPz8gW10pPy5tYXAoeCA9PiB4LnNwbGl0KCcsJykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFzayBmb3IgdGhlIGltcG9ydGFibGUgaWRlbnRpZmllciBmb3IgdGhlIGdpdmVuIHJlc291cmNlXG4gICAqXG4gICAqIFRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIGlkZW50aWZpZXIgdW5kZXIgd2hpY2ggYSByZXNvdXJjZSBjYW4gYmUgaW1wb3J0ZWQuIFRoZSBgaW1wb3J0YFxuICAgKiBvcGVyYXRpb24gbmVlZHMgZXhhY3RseSBvbmUgb2YgdGhlbS5cbiAgICpcbiAgICogLSBJZiB3ZSBjYW4gZ2V0IG9uZSBmcm9tIHRoZSB0ZW1wbGF0ZSwgd2Ugd2lsbCB1c2Ugb25lLlxuICAgKiAtIE90aGVyd2lzZSwgd2Ugd2lsbCBhc2sgdGhlIHVzZXIgZm9yIG9uZSBvZiB0aGVtLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBhc2tGb3JSZXNvdXJjZUlkZW50aWZpZXIoXG4gICAgcmVzb3VyY2VJZGVudGlmaWVyczogUmVzb3VyY2VJZGVudGlmaWVycyxcbiAgICBjaGc6IEltcG9ydGFibGVSZXNvdXJjZSxcbiAgKTogUHJvbWlzZTxSZXNvdXJjZUlkZW50aWZpZXJQcm9wZXJ0aWVzIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgcmVzb3VyY2VOYW1lID0gdGhpcy5kZXNjcmliZVJlc291cmNlKGNoZy5sb2dpY2FsSWQpO1xuXG4gICAgLy8gU2tpcCByZXNvdXJjZXMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpbXBvcnRpbmdcbiAgICBjb25zdCByZXNvdXJjZVR5cGUgPSBjaGcucmVzb3VyY2VEaWZmLm5ld1Jlc291cmNlVHlwZTtcbiAgICBpZiAocmVzb3VyY2VUeXBlID09PSB1bmRlZmluZWQgfHwgIShyZXNvdXJjZVR5cGUgaW4gcmVzb3VyY2VJZGVudGlmaWVycykpIHtcbiAgICAgIHdhcm5pbmcoYCR7cmVzb3VyY2VOYW1lfTogdW5zdXBwb3J0ZWQgcmVzb3VyY2UgdHlwZSAke3Jlc291cmNlVHlwZX0sIHNraXBwaW5nIGltcG9ydC5gKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgaWRQcm9wU2V0cyA9IHJlc291cmNlSWRlbnRpZmllcnNbcmVzb3VyY2VUeXBlXTtcblxuICAgIC8vIFJldGFpbiBvbmx5IGxpdGVyYWwgc3RyaW5nczogc3RyaXAgcG90ZW50aWFsIENGTiBpbnRyaW5zaWNzXG4gICAgY29uc3QgcmVzb3VyY2VQcm9wcyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhjaGcucmVzb3VyY2VEZWZpbml0aW9uLlByb3BlcnRpZXMgPz8ge30pXG4gICAgICAuZmlsdGVyKChbXywgdl0pID0+IHR5cGVvZiB2ID09PSAnc3RyaW5nJykpIGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG5cbiAgICAvLyBGaW5kIHByb3BlcnR5IHNldHMgdGhhdCBhcmUgZnVsbHkgc2F0aXNmaWVkIGluIHRoZSB0ZW1wbGF0ZSwgYXNrIHRoZSB1c2VyIHRvIGNvbmZpcm0gdGhlbVxuICAgIGNvbnN0IHNhdGlzZmllZFByb3BTZXRzID0gaWRQcm9wU2V0cy5maWx0ZXIocHMgPT4gcHMuZXZlcnkocCA9PiByZXNvdXJjZVByb3BzW3BdKSk7XG4gICAgZm9yIChjb25zdCBzYXRpc2ZpZWRQcm9wU2V0IG9mIHNhdGlzZmllZFByb3BTZXRzKSB7XG4gICAgICBjb25zdCBjYW5kaWRhdGVQcm9wcyA9IE9iamVjdC5mcm9tRW50cmllcyhzYXRpc2ZpZWRQcm9wU2V0Lm1hcChwID0+IFtwLCByZXNvdXJjZVByb3BzW3BdXSkpO1xuICAgICAgY29uc3QgZGlzcGxheUNhbmRpZGF0ZVByb3BzID0gZm10ZGljdChjYW5kaWRhdGVQcm9wcyk7XG5cbiAgICAgIGlmIChhd2FpdCBwcm9tcHRseS5jb25maXJtKFxuICAgICAgICBgJHtjaGFsay5ibHVlKHJlc291cmNlTmFtZSl9ICgke3Jlc291cmNlVHlwZX0pOiBpbXBvcnQgd2l0aCAke2NoYWxrLnllbGxvdyhkaXNwbGF5Q2FuZGlkYXRlUHJvcHMpfSAoeWVzL25vKSBbZGVmYXVsdDogeWVzXT8gYCxcbiAgICAgICAgeyBkZWZhdWx0OiAneWVzJyB9LFxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlUHJvcHM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZ290IGhlcmUgYW5kIHRoZSB1c2VyIHJlamVjdGVkIGFueSBhdmFpbGFibGUgaWRlbnRpZmllcnMsIHRoZW4gYXBwYXJlbnRseSB0aGV5IGRvbid0IHdhbnQgdGhlIHJlc291cmNlIGF0IGFsbFxuICAgIGlmIChzYXRpc2ZpZWRQcm9wU2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICBwcmludChjaGFsay5ncmV5KGBTa2lwcGluZyBpbXBvcnQgb2YgJHtyZXNvdXJjZU5hbWV9YCkpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBXZSBjYW5ub3QgYXV0by1pbXBvcnQgdGhpcywgYXNrIHRoZSB1c2VyIGZvciBvbmUgb2YgdGhlIHByb3BzXG4gICAgLy8gVGhlIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZXNlIGNhc2VzIGlzIHdoYXQgd2UgcHJpbnQ6IGZvciBtdWx0aXBsZSBwcm9wZXJ0aWVzLCB3ZSBwcmludCBhIHByZWFtYmxlXG4gICAgY29uc3QgcHJlZml4ID0gYCR7Y2hhbGsuYmx1ZShyZXNvdXJjZU5hbWUpfSAoJHtyZXNvdXJjZVR5cGV9KWA7XG4gICAgbGV0IHByZWFtYmxlO1xuICAgIGxldCBwcm9tcHRQYXR0ZXJuO1xuICAgIGlmIChpZFByb3BTZXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHByZWFtYmxlID0gYCR7cHJlZml4fTogZW50ZXIgb25lIG9mICR7aWRQcm9wU2V0cy5tYXAoeCA9PiBjaGFsay5ibHVlKHguam9pbignKycpKSkuam9pbignLCAnKX0gdG8gaW1wb3J0IChhbGwgZW1wdHkgdG8gc2tpcClgO1xuICAgICAgcHJvbXB0UGF0dGVybiA9IGAke3ByZWZpeH06IGVudGVyICVgO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9tcHRQYXR0ZXJuID0gYCR7cHJlZml4fTogZW50ZXIgJWA7XG4gICAgfVxuXG4gICAgLy8gRG8gdGhlIGlucHV0IGxvb3AgaGVyZVxuICAgIGlmIChwcmVhbWJsZSkge1xuICAgICAgcHJpbnQocHJlYW1ibGUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGlkUHJvcHMgb2YgaWRQcm9wU2V0cykge1xuICAgICAgY29uc3QgaW5wdXQ6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgICAgIGZvciAoY29uc3QgaWRQcm9wIG9mIGlkUHJvcHMpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHZhbHVlIGZyb20gdGhlIHRlbXBsYXRlLCB1c2UgaXQgYXMgZGVmYXVsdC4gVGhpcyB3aWxsIG9ubHkgYmUgYSBwYXJ0aWFsXG4gICAgICAgIC8vIGlkZW50aWZpZXIgaWYgcHJlc2VudCwgb3RoZXJ3aXNlIHdlIHdvdWxkIGhhdmUgZG9uZSB0aGUgaW1wb3J0IGFscmVhZHkgYWJvdmUuXG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHJlc291cmNlUHJvcHNbaWRQcm9wXSA/PyAnJztcblxuICAgICAgICBjb25zdCBwcm9tcHQgPSBbXG4gICAgICAgICAgcHJvbXB0UGF0dGVybi5yZXBsYWNlKC8lL2csIGNoYWxrLmJsdWUoaWRQcm9wKSksXG4gICAgICAgICAgZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICA/IGBbJHtkZWZhdWx0VmFsdWV9XWBcbiAgICAgICAgICAgIDogJyhlbXB0eSB0byBza2lwKScsXG4gICAgICAgIF0uam9pbignICcpICsgJzonO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHByb21wdGx5LnByb21wdChwcm9tcHQsXG4gICAgICAgICAgeyBkZWZhdWx0OiBkZWZhdWx0VmFsdWUsIHRyaW06IHRydWUgfSxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dFtpZFByb3BdID0gcmVzcG9uc2U7XG4gICAgICAgIC8vIEFsc28gc3RpY2sgdGhpcyBwcm9wZXJ0eSBpbnRvICdyZXNvdXJjZVByb3BzJywgc28gdGhhdCBpdCBtYXkgYmUgcmV1c2VkIGJ5IGEgc3Vic2VxdWVudCBxdWVzdGlvblxuICAgICAgICAvLyAoZm9yIGEgZGlmZmVyZW50IGNvbXBvdW5kIGlkZW50aWZpZXIgdGhhdCBpbnZvbHZlcyB0aGUgc2FtZSBwcm9wZXJ0eSkuIEp1c3QgYSBzbWFsbCBVWCBlbmhhbmNlbWVudC5cbiAgICAgICAgcmVzb3VyY2VQcm9wc1tpZFByb3BdID0gcmVzcG9uc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSB1c2VyIGdhdmUgaW5wdXRzIGZvciBhbGwgdmFsdWVzLCB3ZSBhcmUgY29tcGxldGVcbiAgICAgIGlmIChPYmplY3Qua2V5cyhpbnB1dCkubGVuZ3RoID09PSBpZFByb3BzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJpbnQoY2hhbGsuZ3JleShgU2tpcHBpbmcgaW1wb3J0IG9mICR7cmVzb3VyY2VOYW1lfWApKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIGludGVybmFsIFwicmVzb3VyY2UgbWFwcGluZ1wiIHN0cnVjdHVyZSB0byBDbG91ZEZvcm1hdGlvbiBhY2NlcHRlZCBcIlJlc291cmNlc1RvSW1wb3J0XCIgc3RydWN0dXJlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIG1ha2VSZXNvdXJjZXNUb0ltcG9ydChyZXNvdXJjZU1hcDogSW1wb3J0TWFwKTogUHJvbWlzZTxSZXNvdXJjZXNUb0ltcG9ydD4ge1xuICAgIHJldHVybiByZXNvdXJjZU1hcC5pbXBvcnRSZXNvdXJjZXMubWFwKHJlcyA9PiAoe1xuICAgICAgTG9naWNhbFJlc291cmNlSWQ6IHJlcy5sb2dpY2FsSWQsXG4gICAgICBSZXNvdXJjZVR5cGU6IHJlcy5yZXNvdXJjZURpZmYubmV3UmVzb3VyY2VUeXBlISxcbiAgICAgIFJlc291cmNlSWRlbnRpZmllcjogcmVzb3VyY2VNYXAucmVzb3VyY2VNYXBbcmVzLmxvZ2ljYWxJZF0sXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgQ2xvdWRGb3JtYXRpb24gbG9naWNhbCByZXNvdXJjZSBJRCB0byBDREsgY29uc3RydWN0IHRyZWUgcGF0aFxuICAgKlxuICAgKiBAcGFyYW0gbG9naWNhbElkIENsb3VkRm9ybWF0aW9uIGxvZ2ljYWwgSUQgb2YgdGhlIHJlc291cmNlICh0aGUga2V5IGluIHRoZSB0ZW1wbGF0ZSdzIFJlc291cmNlcyBzZWN0aW9uKVxuICAgKiBAcmV0dXJucyBGb3J3YXJkLXNsYXNoIHNlcGFyYXRlZCBwYXRoIG9mIHRoZSByZXNvdXJjZSBpbiBDREsgY29uc3RydWN0IHRyZWUsIGUuZy4gTXlTdGFjay9NeUJ1Y2tldC9SZXNvdXJjZVxuICAgKi9cbiAgcHJpdmF0ZSBkZXNjcmliZVJlc291cmNlKGxvZ2ljYWxJZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjay50ZW1wbGF0ZT8uUmVzb3VyY2VzPy5bbG9naWNhbElkXT8uTWV0YWRhdGE/LlsnYXdzOmNkazpwYXRoJ10gPz8gbG9naWNhbElkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgQ0RLTWV0YWRhdGEgYW5kIE91dHB1dHMgaW4gdGhlIHRlbXBsYXRlIHNvIHRoYXQgb25seSByZXNvdXJjZXMgZm9yIGltcG9ydGluZyBhcmUgbGVmdC5cbiAgICogQHJldHVybnMgdGVtcGxhdGUgd2l0aCBpbXBvcnQgcmVzb3VyY2VzIG9ubHlcbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlTm9uSW1wb3J0UmVzb3VyY2VzKCkge1xuICAgIHJldHVybiByZW1vdmVOb25JbXBvcnRSZXNvdXJjZXModGhpcy5zdGFjayk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIENES01ldGFkYXRhIGFuZCBPdXRwdXRzIGluIHRoZSB0ZW1wbGF0ZSBzbyB0aGF0IG9ubHkgcmVzb3VyY2VzIGZvciBpbXBvcnRpbmcgYXJlIGxlZnQuXG4gKiBAcmV0dXJucyB0ZW1wbGF0ZSB3aXRoIGltcG9ydCByZXNvdXJjZXMgb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTm9uSW1wb3J0UmVzb3VyY2VzKHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QpIHtcbiAgY29uc3QgdGVtcGxhdGUgPSBzdGFjay50ZW1wbGF0ZTtcbiAgZGVsZXRlIHRlbXBsYXRlLlJlc291cmNlcy5DREtNZXRhZGF0YTtcbiAgZGVsZXRlIHRlbXBsYXRlLk91dHB1dHM7XG4gIHJldHVybiB0ZW1wbGF0ZTtcbn1cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCBhIHJlc291cmNlIGluIHRoZSB0ZW1wbGF0ZSB0aGF0IGlzIGltcG9ydGFibGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbXBvcnRhYmxlUmVzb3VyY2Uge1xuICAvKipcbiAgICogVGhlIGxvZ2ljYWwgSUQgb2YgdGhlIHJlc291cmNlXG4gICAqL1xuICByZWFkb25seSBsb2dpY2FsSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJlc291cmNlIGRlZmluaXRpb24gaW4gdGhlIG5ldyB0ZW1wbGF0ZVxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VEZWZpbml0aW9uOiBhbnk7XG5cbiAgLyoqXG4gICAqIFRoZSBkaWZmIGFzIHJlcG9ydGVkIGJ5IGBjbG91ZGZvcm1hdGlvbi1kaWZmYC5cbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlRGlmZjogUmVzb3VyY2VEaWZmZXJlbmNlO1xufVxuXG4vKipcbiAqIFRoZSBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgdG8gZXhlY3V0ZSBhbiBpbXBvcnQgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW1wb3J0TWFwIHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgbG9naWNhbCBJRHMgdG8gcGh5c2ljYWwgbmFtZXNcbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlTWFwOiBSZXNvdXJjZU1hcDtcblxuICAvKipcbiAgICogVGhlIHNlbGVjdGlvbiBvZiByZXNvdXJjZXMgd2UgYXJlIGFjdHVhbGx5IGltcG9ydGluZ1xuICAgKlxuICAgKiBGb3IgZWFjaCBvZiB0aGUgcmVzb3VyY2VzIGluIHRoaXMgbGlzdCwgdGhlcmUgaXMgYSBjb3JyZXNwb25kaW5nIGVudHJ5IGluXG4gICAqIHRoZSBgcmVzb3VyY2VNYXBgIG1hcC5cbiAgICovXG4gIHJlYWRvbmx5IGltcG9ydFJlc291cmNlczogSW1wb3J0YWJsZVJlc291cmNlW107XG59XG5cbmZ1bmN0aW9uIGZtdGRpY3Q8QT4oeHM6IFJlY29yZDxzdHJpbmcsIEE+KSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyh4cykubWFwKChbaywgdl0pID0+IGAke2t9PSR7dn1gKS5qb2luKCcsICcpO1xufVxuXG4vKipcbiAqIEFkZCBhIGRlZmF1bHQgYERlbGV0aW9uUG9saWN5YCBwb2xpY3kuXG4gKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBzZXQgdG8gJ1JldGFpbicsIHRvIGxvd2VyIHJpc2sgb2YgdW5pbnRlbnRpb25hbGx5XG4gKiBkZWxldGluZyBzdGF0ZWZ1bCByZXNvdXJjZXMgaW4gdGhlIHByb2Nlc3Mgb2YgaW1wb3J0aW5nIHRvIENESy5cbiAqL1xuZnVuY3Rpb24gYWRkRGVmYXVsdERlbGV0aW9uUG9saWN5KHJlc291cmNlOiBhbnkpOiBhbnkge1xuICBpZiAocmVzb3VyY2UuRGVsZXRpb25Qb2xpY3kpIHsgcmV0dXJuIHJlc291cmNlOyB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5yZXNvdXJjZSxcbiAgICBEZWxldGlvblBvbGljeTogJ1JldGFpbicsXG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGlzY292ZXJJbXBvcnRhYmxlUmVzb3VyY2VzUmVzdWx0IHtcbiAgcmVhZG9ubHkgYWRkaXRpb25zOiBJbXBvcnRhYmxlUmVzb3VyY2VbXTtcbiAgcmVhZG9ubHkgaGFzTm9uQWRkaXRpb25zOiBib29sZWFuO1xufVxuIl19